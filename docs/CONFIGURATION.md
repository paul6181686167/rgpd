# ‚öôÔ∏è Guide de Configuration Gmail API

## üìã Table des Mati√®res

1. [Configuration Google Cloud](#configuration-google-cloud)
2. [Configuration OAuth 2.0](#configuration-oauth-20)
3. [Configuration de l'Application](#configuration-de-lapplication)
4. [Configuration Avanc√©e](#configuration-avanc√©e)
5. [S√©curit√© et Permissions](#s√©curit√©-et-permissions)
6. [D√©pannage](#d√©pannage)

## üîß Configuration Google Cloud

### 1. Cr√©ation du Projet Google Cloud

#### √âtape 1 : Acc√®s √† Google Cloud Console
1. Visitez https://console.cloud.google.com/
2. Connectez-vous avec votre compte Google
3. Acceptez les conditions d'utilisation si n√©cessaire

#### √âtape 2 : Cr√©ation d'un Nouveau Projet
1. Cliquez sur le s√©lecteur de projet en haut de la page
2. Cliquez sur "Nouveau projet"
3. Remplissez les informations :
   - **Nom du projet** : `Unsubscribe App`
   - **ID du projet** : `unsubscribe-app-[nombre-al√©atoire]`
   - **Organisation** : Laissez vide ou s√©lectionnez votre organisation
4. Cliquez sur "Cr√©er"
5. Attendez que le projet soit cr√©√© (peut prendre quelques minutes)

#### √âtape 3 : Activation de la Facturation (si n√©cessaire)
1. Allez dans "Facturation" dans le menu principal
2. Liez votre projet √† un compte de facturation
3. **Note** : L'utilisation de Gmail API est gratuite pour les quotas normaux

### 2. Activation des APIs N√©cessaires

#### Activation de Gmail API
1. Dans le menu, allez √† "APIs et services" > "Biblioth√®que"
2. Recherchez "Gmail API"
3. Cliquez sur "Gmail API" dans les r√©sultats
4. Cliquez sur "Activer"
5. Attendez l'activation (quelques secondes)

#### V√©rification des Quotas
1. Allez √† "APIs et services" > "Quotas"
2. Filtrez par "Gmail API"
3. V√©rifiez les limites :
   - **Requests per day** : 1,000,000,000
   - **Requests per minute per user** : 250
   - **Requests per second per user** : 25

## üîê Configuration OAuth 2.0

### 1. Configuration de l'√âcran de Consentement

#### √âtape 1 : Acc√®s √† l'√âcran de Consentement
1. Allez √† "APIs et services" > "√âcran de consentement OAuth"
2. S√©lectionnez le type d'utilisateur :
   - **Interne** : Si vous avez un compte Google Workspace
   - **Externe** : Pour les comptes Gmail personnels (recommand√©)
3. Cliquez sur "Cr√©er"

#### √âtape 2 : Informations sur l'Application
Remplissez les champs obligatoires :

**Informations sur l'application**
- **Nom de l'application** : `Unsubscribe App`
- **Email d'assistance utilisateur** : `votre.email@gmail.com`
- **Logo de l'application** : (optionnel)

**Domaine d'application**
- **Domaine autoris√©** : `localhost` (pour le d√©veloppement)
- **Domaine du d√©veloppeur** : `localhost`

**Coordonn√©es du d√©veloppeur**
- **Adresses email** : `votre.email@gmail.com`

#### √âtape 3 : Scopes (Port√©es)
1. Cliquez sur "Ajouter ou supprimer des scopes"
2. Ajoutez les scopes suivants :
   - `https://www.googleapis.com/auth/gmail.readonly`
   - `https://www.googleapis.com/auth/gmail.send`
   - `https://www.googleapis.com/auth/userinfo.email`
3. Cliquez sur "Mettre √† jour"

#### √âtape 4 : Utilisateurs de Test (si Externe)
Si vous avez choisi "Externe", ajoutez votre email comme utilisateur de test :
1. Cliquez sur "Ajouter des utilisateurs"
2. Ajoutez votre adresse email
3. Cliquez sur "Ajouter"

### 2. Cr√©ation des Identifiants OAuth 2.0

#### √âtape 1 : Cr√©ation des Identifiants
1. Allez √† "APIs et services" > "Identifiants"
2. Cliquez sur "Cr√©er des identifiants"
3. S√©lectionnez "ID client OAuth 2.0"

#### √âtape 2 : Configuration du Client
**Type d'application** : `Application Web`

**Nom** : `Unsubscribe App Client`

**URI de redirection autoris√©s** :
- `http://localhost:8001/auth/callback`
- `http://localhost:3000/auth/callback`
- `http://127.0.0.1:8001/auth/callback`

**Origines JavaScript autoris√©es** :
- `http://localhost:3000`
- `http://localhost:8001`
- `http://127.0.0.1:3000`

#### √âtape 3 : T√©l√©chargement des Identifiants
1. Cliquez sur "Cr√©er"
2. Une popup appara√Æt avec vos identifiants
3. Cliquez sur "T√©l√©charger JSON"
4. Sauvegardez le fichier sous `backend/credentials.json`

### 3. Structure du Fichier credentials.json

```json
{
  "web": {
    "client_id": "123456789-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com",
    "project_id": "unsubscribe-app-123456",
    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
    "token_uri": "https://oauth2.googleapis.com/token",
    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
    "client_secret": "GOCSPX-abcdefghijklmnopqrstuvwxyz",
    "redirect_uris": [
      "http://localhost:8001/auth/callback",
      "http://localhost:3000/auth/callback"
    ]
  }
}
```

## üõ†Ô∏è Configuration de l'Application

### 1. Configuration Backend

#### Mise √† jour du fichier .env
```env
# Configuration Gmail API
GOOGLE_CLIENT_ID=123456789-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=GOCSPX-abcdefghijklmnopqrstuvwxyz
GOOGLE_REDIRECT_URI=http://localhost:8001/auth/callback

# Configuration OAuth
OAUTH_SCOPES=https://www.googleapis.com/auth/gmail.readonly,https://www.googleapis.com/auth/gmail.send,https://www.googleapis.com/auth/userinfo.email

# Configuration s√©curit√©
SECRET_KEY=your-super-secret-key-here-32-characters-minimum
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# Configuration email
EMAIL_RATE_LIMIT=10
MAX_EMAILS_PER_SCAN=100
SCAN_TIMEOUT_SECONDS=300
```

#### Cr√©ation du Service Gmail
Cr√©ez le fichier `backend/gmail_service.py` :

```python
import os
import json
import base64
from typing import List, Dict, Optional
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

class GmailService:
    """Service pour interagir avec Gmail API"""
    
    SCOPES = [
        'https://www.googleapis.com/auth/gmail.readonly',
        'https://www.googleapis.com/auth/gmail.send',
        'https://www.googleapis.com/auth/userinfo.email'
    ]
    
    def __init__(self, credentials_path: str = 'credentials.json'):
        self.credentials_path = credentials_path
        self.service = None
        self.creds = None
    
    def authenticate(self, user_id: str) -> bool:
        """Authentifier l'utilisateur avec OAuth 2.0"""
        token_path = f'token_{user_id}.json'
        
        # Charger les tokens existants
        if os.path.exists(token_path):
            self.creds = Credentials.from_authorized_user_file(token_path, self.SCOPES)
        
        # Rafra√Æchir ou obtenir de nouveaux tokens
        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired and self.creds.refresh_token:
                self.creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(
                    self.credentials_path, self.SCOPES
                )
                self.creds = flow.run_local_server(port=0)
            
            # Sauvegarder les tokens
            with open(token_path, 'w') as token:
                token.write(self.creds.to_json())
        
        # Cr√©er le service Gmail
        self.service = build('gmail', 'v1', credentials=self.creds)
        return True
    
    def get_messages(self, query: str = '', max_results: int = 100) -> List[Dict]:
        """R√©cup√©rer les messages Gmail"""
        try:
            results = self.service.users().messages().list(
                userId='me',
                q=query,
                maxResults=max_results
            ).execute()
            
            messages = results.get('messages', [])
            detailed_messages = []
            
            for message in messages:
                msg = self.service.users().messages().get(
                    userId='me',
                    id=message['id']
                ).execute()
                detailed_messages.append(msg)
            
            return detailed_messages
        
        except HttpError as error:
            print(f'Erreur lors de la r√©cup√©ration des messages: {error}')
            return []
    
    def send_message(self, to: str, subject: str, body: str) -> bool:
        """Envoyer un email"""
        try:
            message = MIMEMultipart()
            message['to'] = to
            message['subject'] = subject
            message.attach(MIMEText(body, 'plain'))
            
            raw_message = base64.urlsafe_b64encode(
                message.as_bytes()
            ).decode()
            
            send_message = self.service.users().messages().send(
                userId='me',
                body={'raw': raw_message}
            ).execute()
            
            return True
        
        except HttpError as error:
            print(f'Erreur lors de l\'envoi: {error}')
            return False
    
    def get_user_info(self) -> Dict:
        """Obtenir les informations de l'utilisateur"""
        try:
            profile = self.service.users().getProfile(userId='me').execute()
            return {
                'email': profile.get('emailAddress'),
                'total_messages': profile.get('messagesTotal', 0),
                'total_threads': profile.get('threadsTotal', 0)
            }
        except HttpError as error:
            print(f'Erreur lors de la r√©cup√©ration du profil: {error}')
            return {}
```

### 2. Configuration Frontend

#### Mise √† jour du fichier .env
```env
# Configuration API
REACT_APP_BACKEND_URL=http://localhost:8001
REACT_APP_API_VERSION=v1

# Configuration Gmail
REACT_APP_GOOGLE_CLIENT_ID=123456789-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com

# Configuration application
REACT_APP_NAME=Unsubscribe App
REACT_APP_VERSION=1.0.0
REACT_APP_ENVIRONMENT=development
REACT_APP_DEBUG=true

# Configuration UI
REACT_APP_THEME=light
REACT_APP_LANGUAGE=fr
REACT_APP_TIMEZONE=Europe/Paris
```

## üîß Configuration Avanc√©e

### 1. Configuration des Quotas

#### Quotas par D√©faut
- **Requests per day** : 1,000,000,000
- **Requests per minute per user** : 250
- **Requests per second per user** : 25

#### Surveillance des Quotas
```python
# backend/quota_monitor.py
import time
from collections import defaultdict
from datetime import datetime, timedelta

class QuotaMonitor:
    def __init__(self):
        self.requests_per_user = defaultdict(list)
        self.daily_requests = defaultdict(int)
    
    def check_quota(self, user_id: str) -> bool:
        """V√©rifier si l'utilisateur peut faire une requ√™te"""
        now = datetime.now()
        
        # Nettoyer les anciennes requ√™tes (plus de 1 minute)
        self.requests_per_user[user_id] = [
            req_time for req_time in self.requests_per_user[user_id]
            if now - req_time < timedelta(minutes=1)
        ]
        
        # V√©rifier la limite par minute
        if len(self.requests_per_user[user_id]) >= 250:
            return False
        
        # Enregistrer la requ√™te
        self.requests_per_user[user_id].append(now)
        self.daily_requests[user_id] += 1
        
        return True
```

### 2. Configuration de la S√©curit√©

#### Chiffrement des Tokens
```python
# backend/security.py
import os
from cryptography.fernet import Fernet

class TokenEncryption:
    def __init__(self):
        key = os.environ.get('ENCRYPTION_KEY')
        if not key:
            key = Fernet.generate_key()
            print(f"Nouvelle cl√© g√©n√©r√©e: {key.decode()}")
        self.cipher = Fernet(key)
    
    def encrypt_token(self, token: str) -> str:
        """Chiffrer un token"""
        return self.cipher.encrypt(token.encode()).decode()
    
    def decrypt_token(self, encrypted_token: str) -> str:
        """D√©chiffrer un token"""
        return self.cipher.decrypt(encrypted_token.encode()).decode()
```

### 3. Configuration des Logs

#### Configuration Logging
```python
# backend/logging_config.py
import logging
import os
from datetime import datetime

def setup_logging():
    """Configuration des logs"""
    
    # Cr√©er le r√©pertoire de logs
    os.makedirs('logs', exist_ok=True)
    
    # Configuration du logger principal
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(f'logs/app_{datetime.now().strftime("%Y%m%d")}.log'),
            logging.StreamHandler()
        ]
    )
    
    # Logger sp√©cifique pour Gmail API
    gmail_logger = logging.getLogger('gmail_api')
    gmail_handler = logging.FileHandler(f'logs/gmail_{datetime.now().strftime("%Y%m%d")}.log')
    gmail_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    gmail_logger.addHandler(gmail_handler)
    gmail_logger.setLevel(logging.DEBUG)
    
    return gmail_logger
```

## üîí S√©curit√© et Permissions

### 1. Permissions Gmail Requises

#### Scopes D√©taill√©s
```python
SCOPES = [
    # Lecture des emails
    'https://www.googleapis.com/auth/gmail.readonly',
    
    # Envoi d'emails
    'https://www.googleapis.com/auth/gmail.send',
    
    # Informations utilisateur
    'https://www.googleapis.com/auth/userinfo.email'
]
```

#### Permissions Minimales
- **gmail.readonly** : Lecture seule des emails
- **gmail.send** : Envoi d'emails uniquement
- **userinfo.email** : Adresse email uniquement

### 2. S√©curisation des Credentials

#### Stockage S√©curis√©
```bash
# Permissions strictes sur les fichiers sensibles
chmod 600 backend/credentials.json
chmod 600 backend/token_*.json
chmod 600 backend/.env
```

#### Variables d'Environnement
```env
# Ne jamais committer ces valeurs
GOOGLE_CLIENT_SECRET=GOCSPX-your-secret-here
SECRET_KEY=your-32-character-secret-key-here
ENCRYPTION_KEY=your-fernet-key-here
```

### 3. Validation des Donn√©es

#### Validation des Emails
```python
import re
from email_validator import validate_email, EmailNotValidError

def validate_email_address(email: str) -> bool:
    """Valider une adresse email"""
    try:
        validate_email(email)
        return True
    except EmailNotValidError:
        return False

def sanitize_email_content(content: str) -> str:
    """Nettoyer le contenu d'un email"""
    # Supprimer les balises HTML
    clean_content = re.sub(r'<[^>]+>', '', content)
    
    # Supprimer les caract√®res dangereux
    clean_content = re.sub(r'[<>"\']', '', clean_content)
    
    return clean_content
```

## üêõ D√©pannage

### 1. Erreurs d'Authentification

#### Erreur : "Error 400: invalid_request"
**Causes possibles :**
- URI de redirection non configur√©e
- Mauvais client_id ou client_secret

**Solutions :**
```bash
# V√©rifier les URIs de redirection
cat backend/credentials.json | grep redirect_uris

# V√©rifier les variables d'environnement
echo $GOOGLE_CLIENT_ID
echo $GOOGLE_CLIENT_SECRET
```

#### Erreur : "Error 403: access_denied"
**Causes possibles :**
- Utilisateur non autoris√© (mode externe)
- Scopes non approuv√©s

**Solutions :**
1. Ajouter l'utilisateur dans "Utilisateurs de test"
2. V√©rifier les scopes dans l'√©cran de consentement

### 2. Erreurs de Quotas

#### Erreur : "Error 429: Too Many Requests"
**Solutions :**
```python
# Impl√©menter un syst√®me de retry
import time
from googleapiclient.errors import HttpError

def make_request_with_retry(func, *args, **kwargs):
    """Ex√©cuter une requ√™te avec retry automatique"""
    for attempt in range(3):
        try:
            return func(*args, **kwargs)
        except HttpError as error:
            if error.resp.status == 429:
                wait_time = 2 ** attempt
                print(f"Rate limit atteinte, attente {wait_time}s")
                time.sleep(wait_time)
            else:
                raise error
    
    raise Exception("Nombre maximum de tentatives atteint")
```

### 3. Erreurs de Permissions

#### Erreur : "Error 401: Unauthorized"
**Solutions :**
```python
# V√©rifier et rafra√Æchir les tokens
def refresh_credentials(user_id: str):
    """Rafra√Æchir les credentials"""
    token_path = f'token_{user_id}.json'
    
    if os.path.exists(token_path):
        creds = Credentials.from_authorized_user_file(token_path, SCOPES)
        
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
            
            with open(token_path, 'w') as token:
                token.write(creds.to_json())
            
            return creds
    
    return None
```

### 4. Tests de Configuration

#### Test de Connexion Gmail
```python
# backend/test_gmail_config.py
import sys
from gmail_service import GmailService

def test_gmail_connection():
    """Tester la connexion Gmail"""
    try:
        service = GmailService()
        
        # Test d'authentification
        if service.authenticate('test_user'):
            print("‚úÖ Authentification r√©ussie")
        else:
            print("‚ùå Erreur d'authentification")
            return False
        
        # Test de r√©cup√©ration de messages
        messages = service.get_messages(max_results=1)
        if messages:
            print(f"‚úÖ R√©cup√©ration de messages r√©ussie ({len(messages)} messages)")
        else:
            print("‚ö†Ô∏è  Aucun message r√©cup√©r√©")
        
        # Test d'informations utilisateur
        user_info = service.get_user_info()
        if user_info:
            print(f"‚úÖ Informations utilisateur: {user_info['email']}")
        else:
            print("‚ùå Erreur lors de la r√©cup√©ration des informations utilisateur")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test: {e}")
        return False

if __name__ == "__main__":
    success = test_gmail_connection()
    sys.exit(0 if success else 1)
```

## üìä Monitoring et M√©triques

### 1. M√©triques Gmail API

#### Suivi des Requ√™tes
```python
# backend/metrics.py
from datetime import datetime
from collections import defaultdict

class GmailMetrics:
    def __init__(self):
        self.request_counts = defaultdict(int)
        self.response_times = defaultdict(list)
        self.error_counts = defaultdict(int)
    
    def record_request(self, endpoint: str, response_time: float, success: bool):
        """Enregistrer une requ√™te"""
        self.request_counts[endpoint] += 1
        self.response_times[endpoint].append(response_time)
        
        if not success:
            self.error_counts[endpoint] += 1
    
    def get_stats(self) -> dict:
        """Obtenir les statistiques"""
        return {
            'total_requests': sum(self.request_counts.values()),
            'average_response_time': sum(sum(times) for times in self.response_times.values()) / sum(len(times) for times in self.response_times.values()),
            'error_rate': sum(self.error_counts.values()) / sum(self.request_counts.values()) * 100,
            'requests_by_endpoint': dict(self.request_counts)
        }
```

### 2. Alertes et Notifications

#### Configuration des Alertes
```python
# backend/alerts.py
import smtplib
from email.mime.text import MIMEText

class AlertManager:
    def __init__(self, smtp_server: str, smtp_port: int, email: str, password: str):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.email = email
        self.password = password
    
    def send_alert(self, subject: str, message: str, recipients: list):
        """Envoyer une alerte"""
        try:
            msg = MIMEText(message)
            msg['Subject'] = subject
            msg['From'] = self.email
            msg['To'] = ', '.join(recipients)
            
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.email, self.password)
            server.send_message(msg)
            server.quit()
            
        except Exception as e:
            print(f"Erreur lors de l'envoi d'alerte: {e}")
    
    def check_quota_usage(self, usage_percent: float):
        """V√©rifier l'utilisation du quota"""
        if usage_percent > 80:
            self.send_alert(
                "‚ö†Ô∏è Quota Gmail API √©lev√©",
                f"Utilisation du quota: {usage_percent:.1f}%",
                ["admin@example.com"]
            )
```

---

*Configuration termin√©e avec succ√®s ? Continuez avec le [Guide Utilisateur](USER_GUIDE.md)*